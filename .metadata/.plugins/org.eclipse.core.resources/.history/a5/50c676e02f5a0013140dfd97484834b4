
#include "xparameters.h"                        // Contains hardware addresses and bit masks
#include "xgpio.h"                              // LED and Button driver
#include "xtmrctr.h"
#include "xintc.h"
#include "xtmrctr_l.h"                          // Low-level timer drivers
#include "xintc_l.h"                            // Low-level interrupt controller drivers
#include "mb_interface.h"                       // Very low level bus interface drivers
#include "tetris_vga.h"
#include <xbasic_types.h>                       // XGpio, Xuint32, etc. typedefs
#include <xio.h>                                // Very low-level i/o stuff
#include <stdlib.h>

#define TETRIS_VGA_START 				0xC9A00000
#define RESET_VALUE                 	100000000	// 100M at 50Mhz (20ns/cycle) ~= 2s

XStatus sys_init();
void vga_handler();
void timer_handler();

XIntc sys_intc;
XTmrCtr sys_tmrctr;
XGpio leds;

volatile static char led_cnt = 0xff;

int main(void) {
	int i, ret, top;
	XStatus status;

    status = sys_init();
    if (status != XST_SUCCESS) {
    	xil_printf("Failed to initialize interrupts!\n");
    	return -1;
    }

    xil_printf("Timer addr: %x \n", sys_tmrctr.BaseAddress);
	xil_printf("Timer config: %x \n", XTimerCtr_ReadReg(sys_tmrctr.BaseAddress, 0, XTC_TCSR_OFFSET));
	xil_printf("Timer handler: %x \n", (Xuint32)timer_handler);
	xil_printf("VGA handler: %x \n", (Xuint32)vga_handler);
	//xil_printf("Intc addr: %x \n", sys_intc.BaseAddress);
	//xil_printf("Intc is ready: %x \n", sys_intc.IsReady);
	//xil_printf("Intc is started: %x \n", sys_intc.IsStarted);
	xil_printf("Intc unhandled: %x \n", sys_intc.UnhandledInterrupts);
	//xil_printf("Intc device: %x \n", sys_intc.CfgPtr->DeviceId);
	//xil_printf("Intc options: %x \n", sys_intc.CfgPtr->Options);
	//xil_printf("Intc ISR vector: %x \n", sys_intc.CfgPtr->IntVectorAddr);
	xil_printf("Intc handler[0]: %x \n", sys_intc.CfgPtr->HandlerTable[0].Handler);
	xil_printf("Intc handler[1]: %x \n", sys_intc.CfgPtr->HandlerTable[1].Handler);
	for (i=0; i<0x1d; i+=4) {
		xil_printf("Intc reg %d: %x\n", i, XIntc_In32(sys_intc.BaseAddress+i));
	}

	ret = 0x01234567;
    for (;;) {
    	for (i=0;i<58; i++) {
    		if (i > 1) {
    			TETRIS_VGA_mWriteReg(TETRIS_VGA_START, i<<2, ret);
    			// Poor-man's 4-bit barrel shift
    			top = ret >> 28;
    			ret = ret << 4 | top;
    		}
    	}
    	top = ret >> 28;
    	ret = ret << 4 | top;
		//xil_printf("reg %d: %08x\n", 4, TETRIS_VGA_mReadReg(TETRIS_VGA_START, i<<2));
	}

	return 0;
} // end main

void vga_handler()
{
	xil_printf("VGA interrupt\n");
}

// Read the timer, increment the count, clear the interrupt
void timer_handler()
{
	Xuint32 ControlStatusReg;
	xil_printf("Timer interrupt\n");
	ControlStatusReg = XTimerCtr_ReadReg(sys_tmrctr.BaseAddress, 0, XTC_TCSR_OFFSET);
	led_cnt++;
	XTmrCtr_WriteReg(sys_tmrctr.BaseAddress, 0, XTC_TCSR_OFFSET, ControlStatusReg);
}

int sys_init()
{
	int ret;
    XGpio_Initialize(&leds, XPAR_LEDS_8BIT_DEVICE_ID);
	XIntc_Initialize(&sys_intc, XPAR_XPS_INTC_0_DEVICE_ID);
	XTmrCtr_Initialize(&sys_tmrctr, XPAR_XPS_TIMER_0_DEVICE_ID);

	// Configure GPIO
    XGpio_SetDataDirection(&leds, 1, 0x00000000);

    /* vga interrupt cfg */
	XIntc_Connect(&sys_intc,XPAR_XPS_INTC_0_XPS_TIMER_0_INTERRUPT_INTR,
			(XInterruptHandler)vga_handler, (void*)TETRIS_VGA_START);
    XIntc_Enable(&sys_intc, XPAR_XPS_INTC_0_XPS_TIMER_0_INTERRUPT_INTR);

    /* timer interrupt cfg */
	XIntc_Connect(&sys_intc,XPAR_XPS_INTC_0_XPS_TIMER_0_INTERRUPT_INTR,
			(XInterruptHandler)timer_handler, &sys_tmrctr);
    XIntc_Enable(&sys_intc, XPAR_XPS_INTC_0_XPS_TIMER_0_INTERRUPT_INTR);

    // Enable VGA
    TETRIS_VGA_mWriteReg(TETRIS_VGA_START, 0, 1);
    ret = TETRIS_VGA_mReadReg(TETRIS_VGA_START, 0);
    if (ret)
    	xil_printf("VGA Enabled (%d)\n", ret);

    // Configure and start Timer
    XTmrCtr_SetOptions(&sys_tmrctr, 0, XTC_INT_MODE_OPTION | XTC_AUTO_RELOAD_OPTION);
	XTmrCtr_SetResetValue(&sys_tmrctr, 0, 0xfc000000);
	//XTmrCtr_Start(&sys_tmrctr, 0);

    /* Start interrupts */
	XIntc_Start(&sys_intc, XIN_REAL_MODE);
	microblaze_register_handler((XInterruptHandler)XIntc_DeviceInterruptHandler,
			(void*)XPAR_XPS_INTC_0_DEVICE_ID);
	microblaze_enable_interrupts();

    return XST_SUCCESS;

	/*
	XStatus Status;
	Status = XST_SUCCESS;
	Status = XIntc_Initialize(&sys_intc, XPAR_XPS_INTC_0_DEVICE_ID);
	xil_printf("Interrupt controller driver initialized!\r\n");

	Status = XIntc_Connect(&sys_intc,XPAR_XPS_INTC_0_XPS_TIMER_0_INTERRUPT_INTR,
			(XInterruptHandler)timer_handler, &sys_tmrctr);
	xil_printf("Timer Connected to Interrupt Controller!\r\n");

	Status = XIntc_Start(&sys_intc, XIN_REAL_MODE);
	xil_printf("Started Interrupt Controller!\r\n");

	Status = XTmrCtr_Initialize(&sys_tmrctr, XPAR_XPS_TIMER_0_DEVICE_ID);
	xil_printf("Initialized Timer!\r\n");

	XIntc_Enable(&sys_intc, XPAR_XPS_INTC_0_XPS_TIMER_0_INTERRUPT_INTR);
	XTmrCtr_SetOptions(&sys_tmrctr, 0, XTC_INT_MODE_OPTION | XTC_AUTO_RELOAD_OPTION);

	XTmrCtr_SetResetValue(&sys_tmrctr, 0, 0);
	XTmrCtr_Start(&sys_tmrctr, 0);

	microblaze_register_handler((XInterruptHandler)XIntc_DeviceInterruptHandler,
			(void*)XPAR_XPS_INTC_0_DEVICE_ID);

	microblaze_enable_interrupts();
	xil_printf("Interrupts enabled!\r\n");

	return XST_SUCCESS;
	*/
}



//XIntc   sys_intc;
//XTmrCtr	sys_tmrctr;
//
//void vga_handler();
//void timer_handler();
//
//int main () {
//	int i, ret, top;
//
//	ret = 0x01234567;
//	for (;;) {
//		for (i=0;i<58; i++) {
//			if (i > 1) {
//				TETRIS_VGA_mWriteReg(TETRIS_VGA_START, i<<2, ret);
//				// Poor-man's 4-bit barrel shift
//				top = ret >> 28;
//				ret = ret << 4 | top;
//			}
//		}
//		top = ret >> 28;
//		ret = ret << 4 | top;
//		//xil_printf("reg %d: %08x\n", 4, TETRIS_VGA_mReadReg(TETRIS_VGA_START, i<<2));
//	}
//
////	for (;;) {
////		i = 0;
////		while (100000000<i++) {}
////		TETRIS_VGA_mWriteReg(TETRIS_VGA_USER_SLV_SPACE_OFFSET, 1, 512);
////		i = TETRIS_VGA_mReadReg(TETRIS_VGA_USER_SLV_SPACE_OFFSET, 1);
////		xil_printf("vcnt = 0x%04x, hcnt = 0x%04x\n", i & 0xFFFF, i >> 16);
////	}
//	xil_printf("Bye!");
//	return 0;
//}
//
//void vga_handler()
//{
//  Xuint32 baseaddr;
//  Xuint32 IntrStatus;
//  Xuint32 IpStatus;
//  baseaddr = TETRIS_VGA_START;
//
//  /*
//   * Get status from Device Interrupt Status Register.
//   */
//  IntrStatus = TETRIS_VGA_mReadReg(baseaddr, TETRIS_VGA_INTR_DISR_OFFSET);
//
//  xil_printf("Device Interrupt! DISR value : 0x%08x \n\r", IntrStatus);
//
//  /*
//   * Verify the source of the interrupt is the user logic and clear the interrupt
//   * source by toggle write back to the IP ISR register.
//   */
//  if ( (IntrStatus & INTR_IPIR_MASK) == INTR_IPIR_MASK )
//  {
//    xil_printf("User logic interrupt! \n\r");
//    IpStatus = TETRIS_VGA_mReadReg(baseaddr, TETRIS_VGA_INTR_IPISR_OFFSET);
//    TETRIS_VGA_mWriteReg(baseaddr, TETRIS_VGA_INTR_IPISR_OFFSET, IpStatus);
//  }
//
//}
//
//void timer_handler() {
//	Xuint32 status;
//
//	/* Clear interrupt */
//	xil_printf("Timer interrupt\n\r");
//	XTmrCtr_Reset(&sys_tmrctr, 0);
//	XTmrCtr_Start(&sys_tmrctr,0);
//	status = XTimerCtr_ReadReg(sys_tmrctr.BaseAddress, 0, XTC_TCSR_OFFSET);
//	XTmrCtr_WriteReg(sys_tmrctr.BaseAddress, 0, XTC_TCSR_OFFSET, status|XTC_CSR_INT_OCCURED_MASK);
//}
