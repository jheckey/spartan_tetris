/*****************************************************************************
* bsp.c for Lab2A of ECE 153a at UCSB
* Date of the Last Update:  Aug 26, 2010
*****************************************************************************/

/**/
#include "qpn_port.h"
#include "bsp.h"
#include "lab2b.h"
#include "lcd.h"

/*****************************/
#define DEBOUNCE_TIME 	125000	/* * 20ns = 2.5ms */
/*****************************/

/* Define all variables and Gpio objects here  */
XIntc   sys_intc;
XTmrCtr sys_tmrctr;
XGpio   sys_buttons;
XGpio   sys_encoder;
XGpio   leds;

static unsigned char	click = 0;
static Xuint32			enc = 0;

void write_leds(int val) {	XGpio_DiscreteWrite(&leds,1,val);	}

/*..........................................................................*/
void BSP_init(void) {
/* Setup LED's, etc */
    XGpio_Initialize(&leds, XPAR_LEDS_8BIT_DEVICE_ID);
	XGpio_Initialize(&sys_buttons, XPAR_XPS_GPIO_0_DEVICE_ID);
	XGpio_Initialize(&sys_encoder, XPAR_XPS_GPIO_1_DEVICE_ID);
	XIntc_Initialize(&sys_intc, XPAR_XPS_INTC_0_DEVICE_ID);
	XTmrCtr_Initialize(&sys_tmrctr, XPAR_XPS_TIMER_0_DEVICE_ID);

    XGpio_SetDataDirection(&leds, 1, 0x00000000);
    XGpio_SetDataDirection(&sys_buttons, 1, 0x0000000F);
    XGpio_SetDataDirection(&sys_encoder, 1, 0x00000003);

	XTmrCtr_SetOptions(&sys_tmrctr, 0, XTC_INT_MODE_OPTION);
	XTmrCtr_SetResetValue(&sys_tmrctr, 0, 0xFFFFFFFF-DEBOUNCE_TIME);

	//Initialize the LCD screen
	INIT_LCD();
	//spi_init();
	DisplayClear();

/* Setup interrupts and reference to interrupt handler function(s)  */

    /* timer interrupt cfg */
	XIntc_Connect(&sys_intc,XPAR_XPS_INTC_0_XPS_TIMER_0_INTERRUPT_INTR,
			(XInterruptHandler)timer_handler, &sys_tmrctr);
    XIntc_Enable(&sys_intc, XPAR_XPS_INTC_0_XPS_TIMER_0_INTERRUPT_INTR);

    /* button interrupt cfg */
	XIntc_Connect(&sys_intc,XPAR_XPS_INTC_0_XPS_GPIO_0_IP2INTC_IRPT_INTR,
			(XInterruptHandler)button_handler, &sys_buttons);
	XGpio_InterruptGlobalEnable(&sys_buttons);
	XGpio_InterruptEnable(&sys_buttons,XPAR_XPS_INTC_0_XPS_GPIO_0_IP2INTC_IRPT_INTR);
	XIntc_Enable(&sys_intc, XPAR_XPS_INTC_0_XPS_GPIO_0_IP2INTC_IRPT_INTR);

    /* encoder interrupt cfg */
	XIntc_Connect(&sys_intc,XPAR_XPS_INTC_0_XPS_GPIO_1_IP2INTC_IRPT_INTR,
			(XInterruptHandler)encoder_handler, &sys_encoder);
	XGpio_InterruptGlobalEnable(&sys_encoder);
	XGpio_InterruptEnable(&sys_encoder,XGPIO_IR_CH1_MASK);
	XIntc_Enable(&sys_intc, XPAR_XPS_INTC_0_XPS_GPIO_1_IP2INTC_IRPT_INTR);

    /* Start interrupts */
	XIntc_Start(&sys_intc, XIN_REAL_MODE);
	microblaze_register_handler((XInterruptHandler)XIntc_DeviceInterruptHandler,
			(void*)XPAR_XPS_INTC_0_DEVICE_ID);
	microblaze_enable_interrupts();

    return;
}
/*..........................................................................*/
void QF_onStartup(void) {                 /* entered with interrupts locked */

/* Enable interrupts
	xil_printf("\n\rQF_onStartup");*/
	
}

/* Do not touch QF_onIdle */
/*..........................................................................*/
void QF_onIdle(void) {        /* entered with interrupts locked, see NOTE01 */

    QF_INT_UNLOCK();                       /* unlock interrupts, see NOTE01 */
}

/* Do not touch Q_onAssert */
/*..........................................................................*/
void Q_onAssert(char const Q_ROM * const Q_ROM_VAR file, int line) {
    (void)file;                                   /* avoid compiler warning */
    (void)line;                                   /* avoid compiler warning */
    QF_INT_LOCK();                  
    for (;;) {
    }
}

/* Interrupt handler functions here.  Do not forget to include them in lab2a.h!
To post an event from an ISR, use this template:  
QActive_postISR((QActive *)&AO_Lab2A, SIGNALHERE);
Where the Signals are defined in lab2a.h  */

void button_handler() {
	/* Display status */
    click = XGpio_DiscreteRead(&sys_buttons,1);
	//XGpio_DiscreteWrite(&leds,1,click);

	/* Reset timer */
    if (click) {
		XTmrCtr_Reset(&sys_tmrctr, 0);
		XTmrCtr_Start(&sys_tmrctr, 0);
    }

	/* Clear int */
	XGpio_InterruptClear(&sys_buttons,XGPIO_IR_CH1_MASK);
    //QActive_postISR((QActive *)&AO_Lab2A, ENCODER_CLICK);
}

void encoder_handler() {
	char tmp;

	/* Display status */
    //xil_printf("\n\rTwist");
    tmp = XGpio_DiscreteRead(&sys_encoder,1);
	enc = enc << 2;		// shift the data up for next entry
	enc |= tmp & 3;		// should never be >3, but why chance it
	//xil_printf("\n\rR%-02x", enc);
	//XGpio_DiscreteWrite(&leds,1,enc);	// only get last 8 bits

	/* Update state and Reset timer */
	XTmrCtr_Reset(&sys_tmrctr, 0);
	XTmrCtr_Start(&sys_tmrctr, 0);

	/* Clear int */
	XGpio_InterruptClear(&sys_encoder,XGPIO_IR_CH1_MASK);
	/*
    if (rd1 == rd2 && rd1 == 2) {
        QActive_postISR((QActive *)&AO_Lab2A, ENCODER_UP);
    } else if (rd1 == rd2 && rd1 == 1) {
        QActive_postISR((QActive *)&AO_Lab2A, ENCODER_DOWN);
    }
    */
}

void timer_handler() {
	Xuint32 status;

	/* Check what kicked off the timer */
	if (click) {
	    QActive_postISR((QActive *)&AO_Lab2B, ENCODER_CLICK);
	    click = 0; // play nice, keep your variables clean
	} else if (enc != 0 && enc > 256) {	// really need at least 4 to get a good sequence
		//xil_printf("\n\rD%08x", enc);
		while (enc) {
			switch (enc&0x3f) {
			// cases are deliberately encoded in order of frequency
			// Down sequences have more false positives than Up, so check those first
			case 0x38:	// 0-2-3	0% false
			case 0x1E:	// 2-3-1	0% false
			case 0x3A:	// 2-2-3	0% false
			case 0x2A:	// 2-2-2	4% false
				QActive_postISR((QActive *)&AO_Lab2B, ENCODER_DOWN);
				enc = 0;
				break;
			// Check Up sequences
			case 0x35:	// 1-1-3	2% false
			case 0x2E:	// 1-3-2	0% false
			case 0x15:	// 1-1-1	5% false
			case 0x0B:	// 3-2-0	0% false
				QActive_postISR((QActive *)&AO_Lab2B, ENCODER_UP);
				enc = 0;
				break;
			}
			// remove latest sample and try again; short below smallest value
			enc = enc >> 2;
			if (enc < 0x0B)
				enc = 0;
		}
	}

	/* Clear interrupt */
	XTmrCtr_Reset(&sys_tmrctr, 0);
	XTmrCtr_Stop(&sys_tmrctr,0);
	status = XTimerCtr_ReadReg(sys_tmrctr.BaseAddress, 0, XTC_TCSR_OFFSET);
	XTmrCtr_WriteReg(sys_tmrctr.BaseAddress, 0, XTC_TCSR_OFFSET, status|XTC_CSR_INT_OCCURED_MASK);
}
